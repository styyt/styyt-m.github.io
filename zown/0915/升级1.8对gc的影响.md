---
title: 浅析升级jdk8对jvm/GC（HotSpot）的影响
date: 2019-09-14 16:42:28
tags: 
- gc
- jvm
categories: 
- gc
- jvm
---

## jvm内存结构变化

- 不变点

  1、堆-----堆是所有线程共享的，主要用来存储对象。其中，堆可分为：年轻代和老年代两块区域，

  ​		老年代与年轻代比例使用NewRatio参数来设定比例。比如： **–XX:NewRatio=2表示新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2** ，这也是jdk8的默认比例，也就是老年代 ( Old ) = 2/3 的堆空间大小。

  ​		对于年轻代，一个Eden区和两个Suvivor区（from，to），使用参数SuvivorRatio来设定大小，比如：

  **–XX:SurvivorRatio=8表示Edem : from : to = 8 : 1 : 1，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。**这也是jdk8的默认比例，众所周知：**JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。在这里也就是10%是空闲的**

  2、Java虚拟机栈----线程私有的，主要存放局部变量表，操作数栈，动态链接和方法出口等；

  3、本地方法栈----线程私有的，主要同java虚拟机栈一样，只是保存的是本地方法（**Native方法**）相关属性；

  4、程序计数器----同样是线程私有的，记录当前线程的行号指示器，为线程的切换提供保障；

- 变化点

  8以前：PermGen Space----线程共享的，主要存储类信息、常量池、静态变量、JIT编译后的代码等数据。方法区理论上来说是堆的逻辑组成部分；运行时常量池——是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；设置方法：

  ```java
  -XX:PermSize
  方法区初始大小
  -XX:MaxPermSize
  方法区最大大小
  超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen
  ```

  8以后：移除了PermGen Space，代替它的是元空间（**Metaspace**），设置方法：

  ```java
  -XX:MaxMetaspaceSize
  参数可以设置元空间的最大值，默认是没有上限的，也就是说你的系统内存上限是多少它就是多少。
  -XX:MetaspaceSize
  这个参数是初始化的Metaspace大小，该值越大触发Metaspace GC的时机就越晚。随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加上限也可能降低。
  -XX:MinMetaspaceFreeRatio
  当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。在本机该参数的默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。
  -XX:MaxMetasaceFreeRatio=N 
  当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。
  -XX:MaxMetaspaceExpansion=N 
  Metaspace增长时的最大幅度
  -XX:MinMetaspaceExpansion=N 
  Metaspace增长时的最小幅度
  ```

  注意：**PermGen ！= 方法区**，“PermGen space”是指永久代。方法区和“PermGen space”有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。

  ​		其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如**符号引用**(Symbols)转移到了native heap；**字面量**(interned strings)转移到了java heap；**类的静态变量**(class statics)转移到了java heap。

  ​		这么做可能有以下原因：

  ​				1、字符串存在永久代中，容易出现性能问题和内存溢出。

  ​				2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

  ​				3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

  ​				4、Oracle 可能会将HotSpot 与 JRockit 合二为一。

## 对象是否存活方法

jdk8也没有变化

1、引用计数算法（已废弃）

​		垃圾收集的早期策略，在这中方法中，堆中每个对象都有一个引用计数，每当有一个地方引用他时，引用计数值就+1,当引用失效时，引用计数值就-1，任何时刻引用计数值为0的对象就是可以被回收，当一个对象被垃圾收集时，被它引用 的对象引用计数值就-1，所以在这种方法中一个对象被垃圾收集会导致后续其他对象的垃圾收集行动。

优点：判定效率高；

缺点：不完全准确，当两个对象相互引用的时候就无法回收，导致内存泄漏。

2、可达性分析法

​		这个算法的基本思路就是通过一系列名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。Finalize方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

​		可作为GC Roots对象的包括如下几种：

​    		a.虚拟机栈(栈桢中的本地变量表)中的引用的对象

   		 b.方法区中的类静态属性引用的对象

   		 c.方法区中的常量引用的对像

​			d.本地方法栈中JNI的引用的对象 

## gc算法

这个没有变化，主要还是有：**标记-清除算法、复制算法（年轻代使用的算法）、标记-整理算法（老年代使用的算法）**

## 垃圾回收器

jdk8默认的垃圾回收器为：ParallelGC

可通过如下命令查看，如下图：

```
java -XX:+PrintCommandLineFlags -version

java -XX:+PrintGCDetails -version
```

![jdk8默认的垃圾回收器](/intro/0024.png)

垃圾回收器分类：

![垃圾回收器分类](/intro/0025.png)

- Serial收集器

  一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。
  特点：CPU利用率最高，停顿时间即用户等待时间比较长。
  适用场景：小型应用
  通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

- Parallel收集器
  采用多线程来通过扫描并压缩堆
  特点：停顿时间短，回收效率高，对吞吐量要求高。
  适用场景：大型应用，科学计算，大规模数据采集等。
  通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

- CMS收集器
  采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。
  （1）初始标记
  （2）并发标记
  （3）并发预处理
  （4）重新标记
  （5）并发清除
  （6）并发重置
  特点：响应时间优先，减少垃圾收集停顿时间
  适应场景：服务器、电信领域等。
  通过JVM参数 -XX:+UseConcMarkSweepGC设置

- G1收集器（**jdk9默认**）
  在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。
  特点：支持很大的堆，高吞吐量
    --支持多CPU和垃圾回收线程
    --在主线程暂停的情况下，使用并行收集
    --在主线程运行的情况下，使用并发收集
  实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
  通过JVM参数 –XX:+UseG1GC 使用G1垃圾回收器

当然，**Parallel、CMS、G1各有个的优势，我们需要根据项目实际情况来调整jvm的垃圾回收器，CMS是常规最优选择，更先进的G1则对支持高并发的场景比较有优势**。

